
\Sexpr{set_parent('master.tex')}

\SweaveOpts{fig.path='figs/apply-', fig.align='center',
  fig.show='hold', tidy=FALSE, prompt=TRUE, comment=''}


<<echo=FALSE,error=FALSE,results='hide'>>=
rm(list = ls())
@


\progrtitlepage{7}{The S3 object system}
\progrchapternumber{6}
\progrchapter{The S3 object system}
\progrchapterabstract{%
  Object-oriented programming using the S3 object system.
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The main literature for this section is:
\begin{itemize}
  \item \textit{R Language Definition} by \citet{Rlang}
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Object-oriented programming}

Object-oriented programming is a programming paradigm using
\textbf{objects} to represent a problem as software. Central to any
object-oriented language are the concepts of \textbf{class} and of
\textbf{methods}.

A class is definition, i.e., the blueprint, from which the individual
objects are created. A specific object is then an instance of a
specific class. Classes contains structural, behavioral, and
relational information. .........


R has three object-oriented systems:
\begin{description}
  \item [S3:] ``generic-function'' style; see \rcode{?class}

  \item [S4:] formal ``generic-function'' style with ``multiple
    dispatch''; implemented in the package \rcode{methods}, see
    \rcode{?Classes}, \rcode{?Methods}.

  \item [ReferenceClasses:] ``message-passing'' style; implemented in the package
    \rcode{methods}, see \rcode{?ReferenceClasses}.
\end{description}

This document explains the S3 object system (which I find great!).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Object classes (Structure)}

The S3 system (\rcode{?class}) does not provide formal class
definitions (i.e., classes as blueprints objects). Instead, the class
system is facilitated through the \rcode{class} attribute of an
object; and this attribute simply is a character vector of class names.

An object's class is set using the \rcode{class()} function,
<<>>=
a <- 11
class(a) <- "PrimeNumber"
@
or, equivalently, by setting the \rcode{class} attribute,
<<>>=
a <- 42
attr(a, "class") <- "PrimeNumber"

## One-liner:
a <- structure(a, class = "PrimeNumber")
@

In both cases the object now has an additonal attribute which defines
its class:
<<>>=
a
class(a)
attributes(a)
@

Note that this approach allows to turn any object into an object of
class \rcode{"PrimeNumber"}, whether or not it makes sense.
<<>>=
structure("10", class = "PrimeNumber")
structure("Hello World!", class = "PrimeNumber")
@

Every object has a class,
<<>>=
class(pi)
@
If there is no class attribute set,
<<>>=
attributes(pi)
@
the object has an \textbf{implicit class}, \rcode{matrix},
\rcode{array}, \rcode{data.frame} or the result of \rcode{mode(x)}
\citep[cf.][Section~6.2]{Chambers@2008}.


\paragraph{The Monte-Carlo $\pi$ example.} We use the Monte-Carlo
$\pi$ estimation as example throughout this chapter.

If a circle of radius $R$ is inscribed inside a square with side
length $2 * R$, then the area of the circle will be $\pi * R^2$ and
the area of the square will be $(2 * R)^2$. So the ratio of the area
of the circle to the area of the square will be $\frac{\pi}{4}$.
This means that, if you pick $n$ points at random inside the square,
approximately $n * \frac{\pi}{4}$ of those points should fall inside
the circle. See, for example, \citet{Andersson@2010}.

The following function is an implementation of this algorithm:
<<>>=
mcpi <- function(n) {
  x <- runif(n)
  y <- runif(n)

  inside <- ((x^2 + y^2) <= 1)

  pi <- 4 * sum(inside) / n

  ret <- list(pi = pi,
              n = n,
              sim = data.frame(x = x, y = y, inside = inside))

  class(ret) <- "mcpi"

  ret
}
@

It returns a list with three elements: (1)~the estimeted \rcode{pi},
(2)~the number of drawn points \rcode{n}, (3)~and the simulation data,
a \rcode{data.frame} with the columns \rcode{x} (numeric), \rcode{y}
(numeric), and \rcode{inside} (logical). In order to declare this list
as a ``special'' object, i.e., an object of class \rcode{mcpi}, we
define its class attribute before returning the list.

When executing the function,
<<>>=
set.seed(1234)
mcpi(5)
@
we receive the list with the set class attribute. In the following we
write methods for this \rcode{mcpi} class to make the handling of such
objects straightforward.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Class methods (Behavior)}

In order to define the behavior of objects we have to define
\textbf{generic functions} and corresponding \textbf{methods}
implementing the concrete behavior of specific classes.

Generic functions are functions with the statement
\rcode{UseMethod("...")} in their body. Prominent generic functions
already defined in the \rcode{base} package are \rcode{print()},
\rcode{summary()}, and \rcode{plot()}:
<<>>=
print
@

Methods implementing generic functions follow a simple naming
convention, namely \rcode{generic.class}. The function
\rcode{methods()} lists all available methods for an S3 generic
function; e.g., all available \rcode{print} methods:
<<>>=
head(methods("print"))
@

A generic function (in fact the statement \rcode{UseMethod()}) then
uses the class of the first argument to figure out which method to
call. If no such method is found, the \rcode{default}-method
(\rcode{generic.default}) is used, if it exists, or an error
results. This is called \textbf{method dispatching}.

For example,
<<>>=
a <- 11
class(a)
print(a)
@
Here, the generic function \rcode{print()} first looks for a method
\rcode{print.numeric()}. As such a method is not available, it looks
for the method \rcode{print.default()}, finds it, and passes the call
to this function. The concrete executed function call therefore is
\rcode{print.default(a)}.

Now, let us define the object \rcode{a} as an object of class
\rcode{PrimeNumber}:
<<>>=
class(a) <- "PrimeNumber"
print(a)
@
\rcode{print(a)} still executes \rcode{print.default(a)} as there is
no \rcode{print}-method for the class \rcode{PrimeNumber}
available. However, we easily can implement one:
<<>>=
print.PrimeNumber <- function(x, ...) {
  cat("Prime number:", x, "\n")
}
@
The implementation has to follow the signature of the generic
function.

The method dispatch now finds the specialized \rcode{print}-method and
dispatch to it:
<<>>=
print(a)
@


\paragraph{The Monte-Carlo $\pi$ example.} In case of this example we
can use this object-oriented system to provide a more user-friendly
output.

<<>>=
print.mcpi <- function(x, ...) {
  cat("Monte-Carlo PI:", x$pi, "\n")
}

summary.mcpi <- function(object, ...) {
  hits <- sum(object$sim$inside)

  print(object)
  cat(sprintf("Estimated by %s hits from %s trials.\n",
              object$pi, hits, object$n))
}
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Inheritance (Relation)}





Objects can have more than one class:
<<>>=
class(a) <- c("FavoriteNumber", "Number")
@
This is a simple way to define class/object hierarchies. The order of
the class names defines the inheritance hierarchy; here
\rcode{FavoriteNumber} inherits from \rcode{Number}.




When a generic function fun is applied to an object with class
attribute c("first", "second"), the system searches for a function
called fun.first and, if it finds it, applies it to the object. If no
such function is found, a function called fun.second is tried. If no
class name produces a suitable function, the function fun.default is
used (if it exists). If there is no class attribute, the implicit
class is tried, then the default method.




<<eval=FALSE>>=
  class(ret) <- c("mcpi", class(ret))
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plainnat}
\bibliography{references}
